# ÂêéÁ´ØÊû∂ÊûÑËÆæËÆ°

CCR UI ÁöÑÂêéÁ´ØÊòØ‰∏Ä‰∏™Âü∫‰∫é Rust Âíå Actix Web ÊûÑÂª∫ÁöÑÈ´òÊÄßËÉΩ Web ÊúçÂä°ÔºåË¥üË¥£Â§ÑÁêÜÂâçÁ´ØËØ∑Ê±Ç„ÄÅÊâßË°å CCR ÂëΩ‰ª§Âπ∂ËøîÂõûÁªìÊûú„ÄÇ

## üéØ ËÆæËÆ°ÁõÆÊ†á

ÂêéÁ´ØÊû∂ÊûÑÁöÑ‰∏ªË¶ÅËÆæËÆ°ÁõÆÊ†áÔºö

- **È´òÊÄßËÉΩ**ÔºöÂà©Áî® Rust ÁöÑÈõ∂ÊàêÊú¨ÊäΩË±°Âíå Actix Web ÁöÑÂºÇÊ≠•ÁâπÊÄß
- **ÂÆâÂÖ®ÊÄß**ÔºöÂÜÖÂ≠òÂÆâÂÖ®„ÄÅÁ±ªÂûãÂÆâÂÖ®ÔºåÈò≤Ê≠¢Â∏∏ËßÅÁöÑÂÆâÂÖ®ÊºèÊ¥û
- **ÂèØÈù†ÊÄß**ÔºöÈîôËØØÂ§ÑÁêÜÂÆåÂñÑÔºåÁ≥ªÁªüÁ®≥ÂÆöÊÄßÈ´ò
- **ÂèØÊâ©Â±ïÊÄß**ÔºöÊ®°ÂùóÂåñËÆæËÆ°ÔºåÊòì‰∫éÊ∑ªÂä†Êñ∞ÂäüËÉΩ
- **ÊòìÁª¥Êä§ÊÄß**ÔºöÊ∏ÖÊô∞ÁöÑ‰ª£Á†ÅÁªìÊûÑÂíåÂÆåÂñÑÁöÑÊñáÊ°£

## üèóÔ∏è Êï¥‰ΩìÊû∂ÊûÑ

### Á≥ªÁªüÊû∂ÊûÑÂõæ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Frontend (React)                         ‚îÇ
‚îÇ                 http://localhost:5173                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚îÇ HTTP/JSON API
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Backend (Actix Web + Rust)                   ‚îÇ
‚îÇ                http://localhost:8081                        ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                HTTP Router                           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇConfig Handler‚îÇ  ‚îÇCommand Handler‚îÇ ‚îÇSys Handler‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                         ‚îÇ                                   ‚îÇ
‚îÇ                         ‚îÇ Uses                              ‚îÇ
‚îÇ                         ‚ñº                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ            CLI Executor (Tokio Process)              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Spawns 'ccr' subprocess                           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Captures stdout/stderr                            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Handles timeout (30s)                             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Returns CommandOutput                             ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚îÇ Subprocess spawn
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   CCR CLI Binary                            ‚îÇ
‚îÇ                 (Installed in PATH)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ÊäÄÊúØÊ†à

| ÁªÑ‰ª∂ | ÊäÄÊúØ | ÁâàÊú¨ | Áî®ÈÄî |
|------|------|------|------|
| Web Ê°ÜÊû∂ | Actix Web | 4.9 | HTTP ÊúçÂä°Âô®ÂíåË∑ØÁî± |
| ÂºÇÊ≠•ËøêË°åÊó∂ | Tokio | 1.42 | ÂºÇÊ≠•‰ªªÂä°ÊâßË°å |
| Â∫èÂàóÂåñ | Serde | 1.0 | JSON Â∫èÂàóÂåñ/ÂèçÂ∫èÂàóÂåñ |
| ÈîôËØØÂ§ÑÁêÜ | Anyhow/Thiserror | 1.0/2.0 | ÈîôËØØÂ§ÑÁêÜÂíå‰º†Êí≠ |
| Êó•Âøó | Log/Env_logger | 0.4/0.11 | Êó•ÂøóËÆ∞ÂΩï |
| CLI Ëß£Êûê | Clap | 4.5 | ÂëΩ‰ª§Ë°åÂèÇÊï∞Ëß£Êûê |
| Á≥ªÁªü‰ø°ÊÅØ | Whoami/Num_cpus | 1.5/1.16 | Á≥ªÁªü‰ø°ÊÅØËé∑Âèñ |

## üìÅ È°πÁõÆÁªìÊûÑ

```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs              # Â∫îÁî®ÂÖ•Âè£ÁÇπ
‚îÇ   ‚îú‚îÄ‚îÄ config_reader.rs     # ÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ
‚îÇ   ‚îú‚îÄ‚îÄ models.rs            # Êï∞ÊçÆÊ®°ÂûãÂÆö‰πâ
‚îÇ   ‚îú‚îÄ‚îÄ handlers/            # HTTP ËØ∑Ê±ÇÂ§ÑÁêÜÂô®
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.rs        # ÈÖçÁΩÆÁõ∏ÂÖ≥Êé•Âè£
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command.rs       # ÂëΩ‰ª§ÊâßË°åÊé•Âè£
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ system.rs        # Á≥ªÁªü‰ø°ÊÅØÊé•Âè£
‚îÇ   ‚îî‚îÄ‚îÄ executor/            # ÂëΩ‰ª§ÊâßË°åÂô®
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îî‚îÄ‚îÄ cli_executor.rs  # CLI ÂëΩ‰ª§ÊâßË°å
‚îú‚îÄ‚îÄ Cargo.toml              # È°πÁõÆÈÖçÁΩÆÂíå‰æùËµñ
‚îî‚îÄ‚îÄ README.md               # È°πÁõÆËØ¥Êòé
```

## üîß Ê†∏ÂøÉÊ®°ÂùóËÆæËÆ°

### 1. ‰∏ªÂ∫îÁî®Ê®°Âùó (main.rs)

```rust
use actix_web::{web, App, HttpServer, middleware::Logger};
use actix_cors::Cors;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // ÂàùÂßãÂåñÊó•Âøó
    env_logger::init();
    
    // Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
    let args = Args::parse();
    
    log::info!("Starting CCR UI Backend on port {}", args.port);
    
    // ÂêØÂä® HTTP ÊúçÂä°Âô®
    HttpServer::new(|| {
        App::new()
            .wrap(Logger::default())
            .wrap(cors_config())
            .configure(configure_routes)
    })
    .bind(format!("127.0.0.1:{}", args.port))?
    .run()
    .await
}

fn configure_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api")
            .service(handlers::config::get_configs)
            .service(handlers::config::switch_config)
            .service(handlers::config::validate_configs)
            .service(handlers::command::execute_command)
            .service(handlers::command::list_commands)
            .service(handlers::system::get_system_info)
    );
}
```

### 2. Êï∞ÊçÆÊ®°Âûã (models.rs)

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub name: String,
    pub path: String,
    pub is_active: bool,
}

#[derive(Debug, Deserialize)]
pub struct SwitchConfigRequest {
    pub config_name: String,
}

#[derive(Debug, Deserialize)]
pub struct ExecuteCommandRequest {
    pub command: String,
    pub args: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct CommandOutput {
    pub success: bool,
    pub stdout: String,
    pub stderr: String,
    pub exit_code: Option<i32>,
    pub execution_time_ms: u64,
}

#[derive(Debug, Serialize)]
pub struct SystemInfo {
    pub os: String,
    pub arch: String,
    pub cpu_count: usize,
    pub username: String,
    pub ccr_version: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}
```

### 3. ÈÖçÁΩÆÂ§ÑÁêÜÂô® (handlers/config.rs)

```rust
use actix_web::{web, HttpResponse, Result};
use crate::{models::*, executor::cli_executor::execute_ccr_command};

#[actix_web::get("/configs")]
pub async fn get_configs() -> Result<HttpResponse> {
    match execute_ccr_command("list", &[]).await {
        Ok(output) => {
            if output.success {
                let configs = parse_config_list(&output.stdout)?;
                Ok(HttpResponse::Ok().json(ApiResponse {
                    success: true,
                    data: Some(configs),
                    error: None,
                }))
            } else {
                Ok(HttpResponse::InternalServerError().json(ApiResponse::<Vec<Config>> {
                    success: false,
                    data: None,
                    error: Some(output.stderr),
                }))
            }
        }
        Err(e) => {
            log::error!("Failed to get configs: {}", e);
            Ok(HttpResponse::InternalServerError().json(ApiResponse::<Vec<Config>> {
                success: false,
                data: None,
                error: Some(e.to_string()),
            }))
        }
    }
}

#[actix_web::post("/configs/switch")]
pub async fn switch_config(req: web::Json<SwitchConfigRequest>) -> Result<HttpResponse> {
    match execute_ccr_command("switch", &[&req.config_name]).await {
        Ok(output) => {
            if output.success {
                Ok(HttpResponse::Ok().json(ApiResponse {
                    success: true,
                    data: Some(format!("Switched to config: {}", req.config_name)),
                    error: None,
                }))
            } else {
                Ok(HttpResponse::BadRequest().json(ApiResponse::<String> {
                    success: false,
                    data: None,
                    error: Some(output.stderr),
                }))
            }
        }
        Err(e) => {
            log::error!("Failed to switch config: {}", e);
            Ok(HttpResponse::InternalServerError().json(ApiResponse::<String> {
                success: false,
                data: None,
                error: Some(e.to_string()),
            }))
        }
    }
}

fn parse_config_list(output: &str) -> Result<Vec<Config>, Box<dyn std::error::Error>> {
    let mut configs = Vec::new();
    
    for line in output.lines() {
        if let Some(config) = parse_config_line(line) {
            configs.push(config);
        }
    }
    
    Ok(configs)
}

fn parse_config_line(line: &str) -> Option<Config> {
    // Ëß£Êûê CCR list ÂëΩ‰ª§ÁöÑËæìÂá∫Ê†ºÂºè
    // ‰æãÂ¶Ç: "* config-name (/path/to/config)"
    if line.trim().is_empty() {
        return None;
    }
    
    let is_active = line.starts_with('*');
    let line = line.trim_start_matches('*').trim();
    
    if let Some(space_pos) = line.find(' ') {
        let name = line[..space_pos].to_string();
        let path = line[space_pos + 1..].trim_matches(|c| c == '(' || c == ')').to_string();
        
        Some(Config {
            name,
            path,
            is_active,
        })
    } else {
        None
    }
}
```

### 4. ÂëΩ‰ª§ÊâßË°åÂô® (executor/cli_executor.rs)

```rust
use std::process::Stdio;
use std::time::{Duration, Instant};
use tokio::process::Command;
use tokio::time::timeout;
use anyhow::{Result, anyhow};
use crate::models::CommandOutput;

const COMMAND_TIMEOUT: Duration = Duration::from_secs(30);

pub async fn execute_ccr_command(command: &str, args: &[&str]) -> Result<CommandOutput> {
    let start_time = Instant::now();
    
    log::info!("Executing CCR command: ccr {} {}", command, args.join(" "));
    
    let mut cmd = Command::new("ccr");
    cmd.arg(command);
    cmd.args(args);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());
    
    // ËÆæÁΩÆË∂ÖÊó∂ÊâßË°å
    let result = timeout(COMMAND_TIMEOUT, cmd.output()).await;
    
    let execution_time = start_time.elapsed();
    
    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout).to_string();
            let stderr = String::from_utf8_lossy(&output.stderr).to_string();
            let success = output.status.success();
            let exit_code = output.status.code();
            
            log::info!(
                "Command completed in {}ms, success: {}, exit_code: {:?}",
                execution_time.as_millis(),
                success,
                exit_code
            );
            
            if !success {
                log::warn!("Command stderr: {}", stderr);
            }
            
            Ok(CommandOutput {
                success,
                stdout,
                stderr,
                exit_code,
                execution_time_ms: execution_time.as_millis() as u64,
            })
        }
        Ok(Err(e)) => {
            log::error!("Failed to execute command: {}", e);
            Err(anyhow!("Failed to execute command: {}", e))
        }
        Err(_) => {
            log::error!("Command timed out after {}s", COMMAND_TIMEOUT.as_secs());
            Err(anyhow!("Command timed out after {}s", COMMAND_TIMEOUT.as_secs()))
        }
    }
}

pub async fn execute_arbitrary_command(command: &str, args: &[String]) -> Result<CommandOutput> {
    let start_time = Instant::now();
    
    log::info!("Executing command: {} {}", command, args.join(" "));
    
    let mut cmd = Command::new(command);
    cmd.args(args);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());
    
    let result = timeout(COMMAND_TIMEOUT, cmd.output()).await;
    let execution_time = start_time.elapsed();
    
    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout).to_string();
            let stderr = String::from_utf8_lossy(&output.stderr).to_string();
            let success = output.status.success();
            let exit_code = output.status.code();
            
            Ok(CommandOutput {
                success,
                stdout,
                stderr,
                exit_code,
                execution_time_ms: execution_time.as_millis() as u64,
            })
        }
        Ok(Err(e)) => Err(anyhow!("Failed to execute command: {}", e)),
        Err(_) => Err(anyhow!("Command timed out")),
    }
}
```

### 5. Á≥ªÁªü‰ø°ÊÅØÂ§ÑÁêÜÂô® (handlers/system.rs)

```rust
use actix_web::{HttpResponse, Result};
use crate::{models::*, executor::cli_executor::execute_ccr_command};

#[actix_web::get("/system/info")]
pub async fn get_system_info() -> Result<HttpResponse> {
    let system_info = SystemInfo {
        os: std::env::consts::OS.to_string(),
        arch: std::env::consts::ARCH.to_string(),
        cpu_count: num_cpus::get(),
        username: whoami::username(),
        ccr_version: get_ccr_version().await,
    };
    
    Ok(HttpResponse::Ok().json(ApiResponse {
        success: true,
        data: Some(system_info),
        error: None,
    }))
}

async fn get_ccr_version() -> Option<String> {
    match execute_ccr_command("--version", &[]).await {
        Ok(output) if output.success => {
            Some(output.stdout.trim().to_string())
        }
        _ => None,
    }
}
```

## üîí ÂÆâÂÖ®ÊÄßËÆæËÆ°

### 1. ÂëΩ‰ª§Ê≥®ÂÖ•Èò≤Êä§

```rust
use regex::Regex;

fn validate_command_args(args: &[String]) -> Result<(), String> {
    let dangerous_patterns = [
        r"[;&|`$()]",  // Shell ÁâπÊÆäÂ≠óÁ¨¶
        r"\.\./",      // Ë∑ØÂæÑÈÅçÂéÜ
        r"^-",         // Èò≤Ê≠¢ÂèÇÊï∞Ê≥®ÂÖ•
    ];
    
    for arg in args {
        for pattern in &dangerous_patterns {
            let re = Regex::new(pattern).unwrap();
            if re.is_match(arg) {
                return Err(format!("Dangerous pattern detected in argument: {}", arg));
            }
        }
    }
    
    Ok(())
}
```

### 2. ËæìÂÖ•È™åËØÅ

```rust
use serde::de::{self, Deserializer, Visitor};

impl<'de> Deserialize<'de> for SwitchConfigRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct Helper {
            config_name: String,
        }
        
        let helper = Helper::deserialize(deserializer)?;
        
        // È™åËØÅÈÖçÁΩÆÂêçÁß∞Ê†ºÂºè
        if helper.config_name.is_empty() {
            return Err(de::Error::custom("config_name cannot be empty"));
        }
        
        if helper.config_name.len() > 100 {
            return Err(de::Error::custom("config_name too long"));
        }
        
        // Âè™ÂÖÅËÆ∏Â≠óÊØç„ÄÅÊï∞Â≠ó„ÄÅËøûÂ≠óÁ¨¶Âíå‰∏ãÂàíÁ∫ø
        if !helper.config_name.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
            return Err(de::Error::custom("config_name contains invalid characters"));
        }
        
        Ok(SwitchConfigRequest {
            config_name: helper.config_name,
        })
    }
}
```

### 3. CORS ÈÖçÁΩÆ

```rust
use actix_cors::Cors;

fn cors_config() -> Cors {
    Cors::default()
        .allowed_origin("http://localhost:5173")  // ÂºÄÂèëÁéØÂ¢É
        .allowed_origin("http://127.0.0.1:5173")
        .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])
        .allowed_headers(vec!["Content-Type", "Authorization"])
        .max_age(3600)
}
```

## üìä ÈîôËØØÂ§ÑÁêÜÁ≠ñÁï•

### 1. ÈîôËØØÁ±ªÂûãÂÆö‰πâ

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("CCR command failed: {0}")]
    CcrCommandError(String),
    
    #[error("Configuration not found: {0}")]
    ConfigNotFound(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    
    #[error("System error: {0}")]
    SystemError(String),
    
    #[error("Timeout error: operation took too long")]
    TimeoutError,
}

impl actix_web::ResponseError for AppError {
    fn error_response(&self) -> HttpResponse {
        match self {
            AppError::CcrCommandError(msg) => {
                HttpResponse::InternalServerError().json(ApiResponse::<()> {
                    success: false,
                    data: None,
                    error: Some(msg.clone()),
                })
            }
            AppError::ConfigNotFound(msg) => {
                HttpResponse::NotFound().json(ApiResponse::<()> {
                    success: false,
                    data: None,
                    error: Some(msg.clone()),
                })
            }
            AppError::InvalidInput(msg) => {
                HttpResponse::BadRequest().json(ApiResponse::<()> {
                    success: false,
                    data: None,
                    error: Some(msg.clone()),
                })
            }
            AppError::TimeoutError => {
                HttpResponse::RequestTimeout().json(ApiResponse::<()> {
                    success: false,
                    data: None,
                    error: Some("Request timeout".to_string()),
                })
            }
            AppError::SystemError(msg) => {
                HttpResponse::InternalServerError().json(ApiResponse::<()> {
                    success: false,
                    data: None,
                    error: Some(msg.clone()),
                })
            }
        }
    }
}
```

### 2. Áªü‰∏ÄÈîôËØØÂ§ÑÁêÜ‰∏≠Èó¥‰ª∂

```rust
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use actix_web::middleware::ErrorHandlerResponse;

pub fn error_handler<B>(res: dev::ServiceResponse<B>) -> Result<ErrorHandlerResponse<B>, Error> {
    let status = res.status();
    
    log::error!("HTTP Error {}: {}", status.as_u16(), status.canonical_reason().unwrap_or("Unknown"));
    
    Ok(ErrorHandlerResponse::Response(res.map_into_left_body()))
}
```

## üìà ÊÄßËÉΩ‰ºòÂåñ

### 1. ÂºÇÊ≠•Â§ÑÁêÜ

```rust
use tokio::task;
use std::sync::Arc;

pub async fn execute_multiple_commands(commands: Vec<String>) -> Vec<CommandOutput> {
    let tasks: Vec<_> = commands
        .into_iter()
        .map(|cmd| {
            task::spawn(async move {
                execute_ccr_command(&cmd, &[]).await
            })
        })
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        match task.await {
            Ok(Ok(output)) => results.push(output),
            Ok(Err(e)) => {
                log::error!("Command execution failed: {}", e);
                results.push(CommandOutput {
                    success: false,
                    stdout: String::new(),
                    stderr: e.to_string(),
                    exit_code: None,
                    execution_time_ms: 0,
                });
            }
            Err(e) => {
                log::error!("Task join failed: {}", e);
            }
        }
    }
    
    results
}
```

### 2. ÁºìÂ≠òÊú∫Âà∂

```rust
use std::collections::HashMap;
use std::sync::RwLock;
use std::time::{Duration, Instant};

pub struct CacheEntry<T> {
    data: T,
    timestamp: Instant,
    ttl: Duration,
}

pub struct Cache<T> {
    store: RwLock<HashMap<String, CacheEntry<T>>>,
}

impl<T: Clone> Cache<T> {
    pub fn new() -> Self {
        Self {
            store: RwLock::new(HashMap::new()),
        }
    }
    
    pub fn get(&self, key: &str) -> Option<T> {
        let store = self.store.read().unwrap();
        if let Some(entry) = store.get(key) {
            if entry.timestamp.elapsed() < entry.ttl {
                return Some(entry.data.clone());
            }
        }
        None
    }
    
    pub fn set(&self, key: String, data: T, ttl: Duration) {
        let mut store = self.store.write().unwrap();
        store.insert(key, CacheEntry {
            data,
            timestamp: Instant::now(),
            ttl,
        });
    }
}
```

## üß™ ÊµãËØïÁ≠ñÁï•

### 1. ÂçïÂÖÉÊµãËØï

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_execute_ccr_command() {
        let result = execute_ccr_command("--version", &[]).await;
        assert!(result.is_ok());
        
        let output = result.unwrap();
        assert!(output.success);
        assert!(!output.stdout.is_empty());
    }
    
    #[test]
    fn test_parse_config_line() {
        let line = "* test-config (/path/to/config)";
        let config = parse_config_line(line).unwrap();
        
        assert_eq!(config.name, "test-config");
        assert_eq!(config.path, "/path/to/config");
        assert!(config.is_active);
    }
}
```

### 2. ÈõÜÊàêÊµãËØï

```rust
#[cfg(test)]
mod integration_tests {
    use actix_web::{test, App};
    use super::*;
    
    #[actix_web::test]
    async fn test_get_configs_endpoint() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::get()
            .uri("/api/configs")
            .to_request();
            
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
}
```

## üöÄ ÈÉ®ÁΩ≤ÈÖçÁΩÆ

### 1. Docker ÊîØÊåÅ

```dockerfile
FROM rust:1.70 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release

FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/ccr-ui-backend /usr/local/bin/

EXPOSE 8081

CMD ["ccr-ui-backend", "--port", "8081"]
```

### 2. Á≥ªÁªüÊúçÂä°ÈÖçÁΩÆ

```ini
[Unit]
Description=CCR UI Backend
After=network.target

[Service]
Type=simple
User=ccr-ui
WorkingDirectory=/opt/ccr-ui
ExecStart=/opt/ccr-ui/ccr-ui-backend --port 8081
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

## üìö Áõ∏ÂÖ≥ÊñáÊ°£

- [ÊäÄÊúØÊ†àËØ¶Ëß£](/backend/tech-stack)
- [ÂºÄÂèëÊåáÂçó](/backend/development)
- [API ÊñáÊ°£](/backend/api)
- [ÈÉ®ÁΩ≤ÊåáÂçó](/backend/deployment)
- [ÈîôËØØÂ§ÑÁêÜ](/backend/error-handling)